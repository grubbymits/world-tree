var ae=(r=>(r[r.Colinear=0]="Colinear",r[r.Clockwise=1]="Clockwise",r[r.CounterClockwise=2]="CounterClockwise",r))(ae||{}),R=class{constructor(t,e){this._x=t;this._y=e;Object.freeze(this)}get x(){return this._x}get y(){return this._y}dot(t){let e=this.x*t.x,r=this.y*t.y;return e+r}mag(){return this.dot(this)}angle(t){let e=this.x*t.y-t.x*this.y,r=this.dot(t);return Math.atan2(e,r)}},f=class{constructor(t,e){this._x=t;this._y=e;Object.freeze(this)}get x(){return this._x}get y(){return this._y}add(t){return new f(this.x+t.x,this.y+t.y)}sub(t){return new f(this.x-t.x,this.y-t.y)}diff(t){return new R(this.x-t.x,this.y-t.y)}static orientation(t,e,r){let n=(e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y);return n==0?0:n>0?1:2}},q=class{constructor(t,e){this._p0=t;this._p1=e}get p0(){return this._p0}get p1(){return this._p1}contains(t){return t.x<=Math.max(this.p0.x,this.p1.x)&&t.x>=Math.min(this.p0.x,this.p1.x)&&t.y<=Math.max(this.p0.y,this.p1.y)&&t.y>=Math.min(this.p0.y,this.p1.y)}add(t){let e=this.p0.add(t),r=this.p1.add(t);return new q(e,r)}on(t){let e=t.x-this.p0.x,r=t.y-this.p0.y,n=this.p1.x-this.p0.x,i=this.p1.y-this.p0.y;return e*i-r*n==0}intersects(t){if(this.on(t.p0)||this.on(t.p1))return!1;let e=f.orientation(this.p0,this.p1,t.p0),r=f.orientation(this.p0,this.p1,t.p1),n=f.orientation(t.p0,t.p1,this.p0),i=f.orientation(t.p0,t.p1,this.p1);return!!(e!=r&&n!=i||e==0&&this.contains(t.p0)||r==0&&this.contains(t.p1)||n==0&&t.contains(this.p0)||i==0&&t.contains(this.p1))}distance(t){let e=this.p0.x*this.p1.y-this.p1.x*this.p0.y,r=this.p0.x*t.y-t.x*this.p0.y,n=1/Math.sqrt(Math.pow(this.p1.x-this.p0.x,2)+Math.pow(this.p1.y-this.p0.y,2));return e*r*n}},y=class{constructor(t,e,r){this._x=t;this._y=e;this._z=r;Object.freeze(this)}get x(){return this._x}get y(){return this._y}get z(){return this._z}add(t){return new y(this.x+t.x,this.y+t.y,this.z+t.z)}mul(t){return new y(this.x*t.x,this.y*t.y,this.z*t.z)}addScalar(t){return new y(this.x+t,this.y+t,this.z+t)}sub(t){return new y(this.x-t.x,this.y-t.y,this.z-t.z)}vec_diff(t){return new w(this.x-t.x,this.y-t.y,this.z-t.z)}isSameAsRounded(t){return Math.round(this.x)==Math.round(t.x)&&Math.round(this.y)==Math.round(t.y)&&Math.round(this.z)==Math.round(t.z)}isSameAs(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}},w=class{constructor(t,e,r){this._x=t;this._y=e;this._z=r;Object.freeze(this)}get x(){return this._x}get y(){return this._y}get z(){return this._z}get zero(){return this.x===0&&this.y===0&&this.z===0}get asString(){return"(x, y, z) = ("+this.x+", "+this.y+", "+this.z+")"}add(t){let e=this.x+t.x,r=this.y+t.y,n=this.z+t.z;return new w(e,r,n)}mulScalar(t){let e=this.x*t,r=this.y*t,n=this.z*t;return new w(e,r,n)}dot(t){let e=this.x*t.x,r=this.y*t.y,n=this.z*t.z;return e+r+n}mag(){return this.dot(this)}cross(t){let e=this.y*t.z-this.z*t.y,r=this.z*t.x-this.x*t.z,n=this.x*t.y-this.y*t.x;return new w(e,r,n)}norm(){return Math.sqrt(this.dot(this))}angle(t){let e=this.cross(t).mag(),r=this.dot(t);return Math.atan2(e,r)}absMin(t){let e=Math.abs(this.x)<Math.abs(t.x)?this.x:t.x,r=Math.abs(this.y)<Math.abs(t.y)?this.y:t.y,n=Math.abs(this.z)<Math.abs(t.z)?this.z:t.z;return new w(e,r,n)}equal(t){return this.x==t.x&&this.y==t.y&&this.z==t.z}},m=class{constructor(t,e,r){this._point=t;this._u=e.vec_diff(t),this._v=r.vec_diff(t),this._normal=this.u.cross(this.v)}get point(){return this._point}get normal(){return this._normal}get u(){return this._u}get v(){return this._v}transform(t){this._point=this.point.add(t)}get asString(){return"normal = "+this.normal.asString+", u = "+this.u.asString+", v = "+this.u.asString}distance(t){let e=-this.normal.dot(t.vec_diff(this.point)),r=this.normal.dot(this.normal),n=e/r,i=t.addScalar(n).mul(this.normal);return t.vec_diff(i).norm()}intersects(t,e){let r=e.vec_diff(t),n=t.vec_diff(this.point),i=-this.normal.dot(n),s=this.normal.dot(r);if(Math.abs(s)<.01)return null;let o=i/s;return o<0||o>1?null:t.add(r.mulScalar(o))}},Q=class{constructor(t){this._vertex=t}get vertex(){return this._vertex}get plane(){return this._vertex}intersectsPlane(t,e){return this.plane.intersects(t,e)}},S=class extends Q{constructor(e){super(e);let r=this.vertex.u,n=this.vertex.v;this._uDotv=r.dot(n),this._uDotu=r.dot(r),this._vDotv=n.dot(n),this._denominator=1/(Math.pow(this._uDotv,2)-this._uDotu*this._vDotv)}vertices(){return[this.vertex]}transform(e){this.vertex.transform(e)}intersects(e){let r=e.vec_diff(this.vertex.point),n=this.vertex.u,i=this.vertex.v,s=r.dot(i),o=r.dot(n),h=(this._uDotv*s-this._vDotv*o)*this._denominator,a=(this._uDotv*o-this._uDotu*s)*this._denominator;return h>=0&&a>=0&&h+a<=1}},x=class extends Q{constructor(e,r){super(e);if(!e.normal.equal(r.normal))throw"Expected QuadFace3D vertices to have equilavent normals";this._triangleA=new S(e),this._triangleB=new S(r)}vertices(){return[this._triangleA.vertex,this._triangleB.vertex]}transform(e){this._triangleA.transform(e),this._triangleB.transform(e)}intersects(e){return this._triangleA.intersects(e)||this._triangleB.intersects(e)}},vt=class{constructor(t,e,r,n,i){this._face=t;this._begin=e;this._end=r;this._i=n;this._theta=i}get face(){return this._face}get begin(){return this._begin}get end(){return this._end}get i(){return this._i}get theta(){return this._theta}},F=class{constructor(t){this._bounds=t;this._faces=new Array;this._widthVec3D=new w(t.width,0,0),this._depthVec3D=new w(0,t.depth,0),this._heightVec3D=new w(0,0,t.height)}get bounds(){return this._bounds}get widthVec3D(){return this._widthVec3D}get depthVec3D(){return this._depthVec3D}get heightVec3D(){return this._heightVec3D}get intersectInfo(){return this._intersectInfo}get name(){return this._name}transform(t){for(let e of this._faces)e.transform(t)}obstructs(t,e){for(let r of this._faces){let n=r.intersectsPlane(t,e);if(n!=null&&r.intersects(n)){let i=n.vec_diff(t),s=r.plane.normal,o=i.angle(s);return new vt(r,t,e,n,o)}}return null}},Vt=class extends F{constructor(t){super(t),this._name="NoGeometry"}obstructs(t,e){return null}},K=class extends F{constructor(t){super(t),this._name="CuboidGeometry";let e=[this.bounds.minLocation,this.bounds.minLocation.add(this.heightVec3D),this.bounds.minLocation.add(this.depthVec3D),this.bounds.minLocation.add(this.widthVec3D),this.bounds.maxLocation.sub(this.heightVec3D),this.bounds.maxLocation.sub(this.depthVec3D),this.bounds.maxLocation.sub(this.widthVec3D),this.bounds.maxLocation],r=new m(e[2],e[6],e[0]),n=new m(e[1],e[0],e[6]);this._faces.push(new x(r,n));let i=new m(e[4],e[7],e[2]),s=new m(e[6],e[2],e[7]);this._faces.push(new x(i,s));let o=new m(e[3],e[5],e[4]),h=new m(e[7],e[4],e[5]);this._faces.push(new x(o,h));let a=new m(e[5],e[1],e[7]),c=new m(e[6],e[7],e[1]);this._faces.push(new x(a,c));let l=new m(e[0],e[3],e[2]),b=new m(e[4],e[2],e[3]);this._faces.push(new x(l,b));let d=new m(e[0],e[1],e[3]),_=new m(e[5],e[3],e[1]);this._faces.push(new x(d,_))}},J=class extends F{constructor(t){super(t),this._name="RampUpWestGeometry";let e=[this.bounds.minLocation,this.bounds.minLocation.add(this.depthVec3D),this.bounds.minLocation.add(this.widthVec3D),this.bounds.maxLocation.sub(this.heightVec3D),this.bounds.minLocation.add(this.heightVec3D),this.bounds.maxLocation.sub(this.widthVec3D)],r=new m(e[1],e[5],e[0]),n=new m(e[4],e[0],e[5]);this._faces.push(new x(r,n)),this._faces.push(new S(new m(e[1],e[3],e[5])));let i=new m(e[2],e[4],e[3]),s=new m(e[5],e[3],e[4]);this._faces.push(new x(i,s));let o=new m(e[3],e[1],e[2]),h=new m(e[0],e[2],e[1]);this._faces.push(new x(o,h)),this._faces.push(new S(new m(e[0],e[4],e[2])))}},$=class extends F{constructor(t){super(t),this._name="RampUpEastGeometry";let e=[this.bounds.minLocation,this.bounds.minLocation.add(this.depthVec3D),this.bounds.minLocation.add(this.widthVec3D),this.bounds.maxLocation.sub(this.heightVec3D),this.bounds.maxLocation.sub(this.depthVec3D),this.bounds.maxLocation],r=new m(e[1],e[5],e[0]),n=new m(e[4],e[0],e[5]),i=new x(r,n);this._faces.push(i);let s=new S(new m(e[3],e[5],e[1]));this._faces.push(s);let o=new m(e[2],e[4],e[3]),h=new m(e[5],e[3],e[4]),a=new x(o,h);this._faces.push(a);let c=new m(e[1],e[0],e[3]),l=new m(e[2],e[3],e[0]),b=new x(c,l);this._faces.push(b);let d=new S(new m(e[4],e[2],e[0]));this._faces.push(d)}},tt=class extends F{constructor(t){super(t),this._name="RampUpNorthGeometry";let e=[this.bounds.minLocation,this.bounds.minLocation.add(this.depthVec3D),this.bounds.minLocation.add(this.heightVec3D),this.bounds.maxLocation.sub(this.depthVec3D),this.bounds.maxLocation.sub(this.heightVec3D),this.bounds.minLocation.add(this.widthVec3D)],r=new S(new m(e[0],e[1],e[2]));this._faces.push(r);let n=new m(e[1],e[4],e[2]),i=new m(e[3],e[2],e[4]),s=new x(n,i);this._faces.push(s);let o=new S(new m(e[5],e[3],e[4]));this._faces.push(o);let h=new m(e[0],e[2],e[5]),a=new m(e[3],e[5],e[2]),c=new x(h,a);this._faces.push(c);let l=new m(e[1],e[4],e[0]),b=new m(e[5],e[0],e[4]),d=new x(l,b);this._faces.push(d)}},et=class extends F{constructor(t){super(t),this._name="RampUpSouthGeometry";let e=[this.bounds.minLocation,this.bounds.minLocation.add(this.depthVec3D),this.bounds.maxLocation.sub(this.widthVec3D),this.bounds.maxLocation,this.bounds.maxLocation.sub(this.heightVec3D),this.bounds.minLocation.add(this.widthVec3D)],r=new S(new m(e[0],e[1],e[2]));this._faces.push(r);let n=new m(e[1],e[4],e[2]),i=new m(e[3],e[2],e[4]),s=new x(n,i);this._faces.push(s);let o=new S(new m(e[5],e[3],e[4]));this._faces.push(o);let h=new m(e[0],e[2],e[5]),a=new m(e[3],e[5],e[2]),c=new x(h,a);this._faces.push(c);let l=new m(e[1],e[4],e[0]),b=new m(e[5],e[0],e[4]),d=new x(l,b);this._faces.push(d)}};var z=(i=>(i.Moving="moving",i.EndMove="endMove",i.FaceDirection="faceDirection",i.Collision="collision",i.NoCollision="noCollision",i))(z||{}),Dt=(t=>(t.CameraMove="cameraMove",t))(Dt||{}),G=class{constructor(){this._listeners=new Map;this._events=new Set}post(t){this._events.add(t)}service(){for(let t of this._events){if(!this._listeners.has(t))continue;let e=this._listeners.get(t);for(let r of e)r()}this._events.clear()}addEventListener(t,e){if(!this._listeners.has(t))this._listeners.set(t,new Array);else{let r=this._listeners.get(t);for(let n in r)if(r[n]===e)return}this._listeners.get(t).push(e)}removeEventListener(t,e){if(!this._listeners.has(t))return;let r=this._listeners.get(t),n=r.indexOf(e,0);n>-1&&r.splice(n,1)}},rt=class{constructor(){this._callbacks=new Array}add(t){this._callbacks.push(t)}service(){for(let t=this._callbacks.length-1;t>=0;t--)this._callbacks[t]()&&this._callbacks.splice(t,1)}};var L=class{constructor(t,e,r){this._width=t;this._depth=e;this._height=r}get width(){return this._width}get depth(){return this._depth}get height(){return this._height}log(){console.log(" - (WxDxH):",this.width,this.depth,this.height)}},C=class{constructor(t,e){this._centre=t;this._dimensions=e;this.centre=t}get minLocation(){return this._minLocation}get minX(){return this.minLocation.x}get minY(){return this.minLocation.y}get minZ(){return this.minLocation.z}get maxLocation(){return this._maxLocation}get maxX(){return this.maxLocation.x}get maxY(){return this.maxLocation.y}get maxZ(){return this.maxLocation.z}get bottomCentre(){return this._bottomCentre}get width(){return this._dimensions.width}get depth(){return this._dimensions.depth}get height(){return this._dimensions.height}get dimensions(){return this._dimensions}get centre(){return this._centre}set centre(t){this._centre=t;let e=this.width/2,r=this.depth/2,n=this.height/2,i=t.x-e,s=t.y-r,o=t.z-n;this._bottomCentre=new y(t.x,t.y,o),this._minLocation=new y(i,s,o),i=t.x+e,s=t.y+r,o=t.z+n,this._maxLocation=new y(i,s,o)}update(t){this._centre=this._centre.add(t),this._bottomCentre=this._bottomCentre.add(t),this._minLocation=this._minLocation.add(t),this._maxLocation=this._maxLocation.add(t)}contains(t){return!(t.x<this._minLocation.x||t.y<this._minLocation.y||t.z<this._minLocation.z||t.x>this._maxLocation.x||t.y>this._maxLocation.y||t.z>this._maxLocation.z)}containsBounds(t){return this.contains(t.minLocation)&&this.contains(t.maxLocation)}intersects(t){return!(t.minLocation.x>this.maxLocation.x||t.maxLocation.x<this.minLocation.x||t.minLocation.y>this.maxLocation.y||t.maxLocation.y<this.minLocation.y||t.minLocation.z>this.maxLocation.z||t.maxLocation.z<this.minLocation.z)}axisOverlapX(t){return t.minLocation.x>=this.minLocation.x&&t.minLocation.x<=this.maxLocation.x||t.maxLocation.x>=this.minLocation.x&&t.maxLocation.x<=this.maxLocation.x}axisOverlapY(t){return t.minLocation.y>=this.minLocation.y&&t.minLocation.y<=this.maxLocation.y||t.maxLocation.y>=this.minLocation.y&&t.maxLocation.y<=this.maxLocation.y}axisOverlapZ(t){return t.minLocation.z>=this.minLocation.z&&t.minLocation.z<=this.maxLocation.z||t.maxLocation.z>=this.minLocation.z&&t.maxLocation.z<=this.maxLocation.z}insert(t){if(this.containsBounds(t))return;let e=t.minLocation.x<this.minLocation.x?t.minLocation.x:this.minLocation.x,r=t.minLocation.y<this.minLocation.y?t.minLocation.y:this.minLocation.y,n=t.minLocation.z<this.minLocation.z?t.minLocation.z:this.minLocation.z,i=t.maxLocation.x>this.maxLocation.x?t.maxLocation.x:this.maxLocation.x,s=t.maxLocation.y>this.maxLocation.y?t.maxLocation.y:this.maxLocation.y,o=t.maxLocation.z>this.maxLocation.z?t.maxLocation.z:this.maxLocation.z;this._dimensions=new L(i-e,s-r,o-n);let h=new y(e,r,n),a=new y(i,s,o),c=(a.x-h.x)/2,l=(a.y-h.y)/2,b=(a.z-h.z)/2;this._centre=new y(h.x+c,h.y+l,h.z+b),this._minLocation=h,this._maxLocation=a}dump(){console.log("BoundingCuboid"),console.log(" - min (x,y,z):",this.minLocation.x,this.minLocation.y,this.minLocation.z),console.log(" - max (x,y,z):",this.maxLocation.x,this.maxLocation.y,this.maxLocation.z),console.log(" - centre (x,y,z):",this.centre.x,this.centre.y,this.centre.z),console.log(" - dimensions (WxDxH):",this.width,this.depth,this.height)}},St=class{constructor(t,e,r){this._collidedEntity=t;this._blocking=e;this._intersectInfo=r}get entity(){return this._collidedEntity}get blocking(){return this._blocking}get intersectInfo(){return this._intersectInfo}},v=class{static init(t){this._spatialInfo=t,this._collisionInfo=new Map,this._missInfo=new Map}static hasCollideInfo(t){return this._collisionInfo.has(t)}static getCollideInfo(t){return console.assert(this.hasCollideInfo(t)),this._collisionInfo.get(t)}static removeInfo(t){this._collisionInfo.delete(t)}static removeMissInfo(t){this._missInfo.delete(t)}static addMissInfo(t,e){this._missInfo.set(t,e)}static hasMissInfo(t){return this._missInfo.has(t)}static getMissInfo(t){return console.assert(this.hasMissInfo(t)),this._missInfo.get(t)}static detectInArea(t,e,r){let n=t.bounds,i=new w(n.width,0,0),s=new w(0,n.depth,0),o=new w(0,0,n.height),h=[n.minLocation,n.minLocation.add(o),n.minLocation.add(s),n.minLocation.add(i),n.maxLocation.sub(o),n.maxLocation.sub(s),n.maxLocation.sub(i),n.maxLocation],a=new Array,c=this._spatialInfo.getEntities(r);for(let l of c){if(l.id==t.id)continue;let b=l.geometry;for(let d of h){let _=d.add(e),A=b.obstructs(d,_);if(A!=null){let N=new St(l,!0,A);return this._collisionInfo.set(t,N),t.postEvent("collision"),N}else a.push(l),t.postEvent("noCollision")}}return this.addMissInfo(t,a),null}},O=class{static init(t,e){this._force=-t,this._context=e,this._enabled=!0}static update(t){if(this._enabled&&this._force<0){let e=new w(0,0,this._force);t.forEach(r=>{let n=r.bounds,i=new C(n.centre.add(e),n.dimensions);i.insert(n),v.detectInArea(r,e,i)==null&&r.updatePosition(e)})}}};O._enabled=!1,O._force=0;var it=class{constructor(t,e,r){this._context=t;this._visible=!0;this._drawable=!1;this._drawGeometry=!1;this._handler=new G;this._graphicComponents=new Array;this._id=it._ids,it._ids++;let n=new y(e.x+r.width/2,e.y+r.depth/2,e.z+r.height/2),i=new C(n,r);this._geometry=new K(i),this._context.addEntity(this)}static reset(){this._ids=0}static getNumEntities(){return this._ids}get context(){return this._context}get geometry(){return this._geometry}get bounds(){return this._geometry.bounds}get dimensions(){return this.bounds.dimensions}get x(){return this.bounds.minX}get y(){return this.bounds.minY}get z(){return this.bounds.minZ}get width(){return this.bounds.width}get depth(){return this.bounds.depth}get height(){return this.bounds.height}get centre(){return this.bounds.centre}get id(){return this._id}get visible(){return this._visible}set visible(t){this._visible=t}get drawable(){return this._drawable}get drawGeometry(){return this._drawGeometry}get graphics(){return this._graphicComponents}get graphic(){return this._graphicComponents[0]}addGraphic(t){this._drawable=!0,this._graphicComponents.push(t)}updatePosition(t){this.bounds.update(t),this.geometry.transform(t)}addEventListener(t,e){this._handler.addEventListener(t,e)}removeEventListener(t,e){this._handler.removeEventListener(t,e)}postEvent(t){this._handler.post(t)}update(){this._handler.service()}},T=it;T._ids=0;var nt=class extends T{constructor(e,r,n){super(e,r,n);this._lift=0;this._canSwim=!1;e.addMovableEntity(this)}updatePosition(e){this.bounds.update(e),this.geometry.transform(e),this.postEvent("moving")}get lift(){return this._lift}get direction(){return this._direction}set direction(e){this._direction=e,this.postEvent("faceDirection")}},Et=class extends nt{constructor(e,r,n){super(e,r,n);e.addUpdateableEntity(this)}update(){super.update(),this._action!=null&&this._action.perform()&&(this._action=null)}set action(e){this._action=e}};function Le(u,t,e,r){let n=new T(u,t,e);return n.addGraphic(r),n}function Ce(u,t,e,r){let n=new nt(u,t,e);return n.addGraphic(r),n}function Te(u,t,e,r){let n=new Et(u,t,e);return n.addGraphic(r),n}var Wt=(p=>(p[p.Flat=0]="Flat",p[p.Wall=1]="Wall",p[p.FlatWest=2]="FlatWest",p[p.FlatEast=3]="FlatEast",p[p.FlatNorthWest=4]="FlatNorthWest",p[p.FlatNorth=5]="FlatNorth",p[p.FlatNorthEast=6]="FlatNorthEast",p[p.FlatSouthWest=7]="FlatSouthWest",p[p.FlatSouth=8]="FlatSouth",p[p.FlatSouthEast=9]="FlatSouthEast",p[p.FlatNorthOut=10]="FlatNorthOut",p[p.FlatEastOut=11]="FlatEastOut",p[p.FlatWestOut=12]="FlatWestOut",p[p.FlatSouthOut=13]="FlatSouthOut",p[p.FlatAloneOut=14]="FlatAloneOut",p[p.RampUpSouthEdge=15]="RampUpSouthEdge",p[p.RampUpWestEdge=16]="RampUpWestEdge",p[p.RampUpEastEdge=17]="RampUpEastEdge",p[p.RampUpNorthEdge=18]="RampUpNorthEdge",p[p.RampUpSouth=19]="RampUpSouth",p[p.RampUpWest=20]="RampUpWest",p[p.RampUpEast=21]="RampUpEast",p[p.RampUpNorth=22]="RampUpNorth",p[p.Max=23]="Max",p))(Wt||{}),Bt=(d=>(d[d.Water=0]="Water",d[d.Lowland0=1]="Lowland0",d[d.Lowland1=2]="Lowland1",d[d.Lowland2=3]="Lowland2",d[d.Lowland3=4]="Lowland3",d[d.Lowland4=5]="Lowland4",d[d.Lowland5=6]="Lowland5",d[d.Upland0=7]="Upland0",d[d.Upland1=8]="Upland1",d[d.Upland2=9]="Upland2",d[d.Upland3=10]="Upland3",d[d.Upland4=11]="Upland4",d[d.Upland5=12]="Upland5",d))(Bt||{}),At=(a=>(a[a.None=0]="None",a[a.Shoreline=1]="Shoreline",a[a.ShorelineNorth=2]="ShorelineNorth",a[a.ShorelineEast=4]="ShorelineEast",a[a.ShorelineSouth=8]="ShorelineSouth",a[a.ShorelineWest=16]="ShorelineWest",a[a.DryGrass=32]="DryGrass",a[a.WetGrass=64]="WetGrass",a[a.Mud=128]="Mud",a))(At||{});function he(u,t){return(u&t)==t}var P=class extends T{constructor(e,r,n,i,s,o,h,a){super(e,new y(r*s.width,n*s.depth,i*s.height),s);this._gridX=r;this._gridY=n;this._gridZ=i;this._type=o;this._shape=h;if(this.addGraphic(P.graphics(o,h)),P.isFlat(h))this._tanTheta=0;else{let d=Math.atan(this.height/this.depth)*180/Math.PI;this._tanTheta=Math.tan(d)}this._shape==20?this._geometry=new J(this.geometry.bounds):this._shape==21?this._geometry=new $(this.geometry.bounds):this._shape==19?this._geometry=new et(this.geometry.bounds):this._shape==22&&(this._geometry=new tt(this.geometry.bounds));let c=this.bounds.centre.x,l=this.bounds.centre.y,b=this.heightAt(this.bounds.centre);if(this._surfaceLocation=new y(c,l,b),a!=0)for(let d of Object.values(At)){let _=d;P.isSupportedFeature(_)&&he(a,_)&&this.addGraphic(P.featureGraphics(_))}}static reset(){this._dimensions=new L(0,0,0),this._featureGraphics=new Map,this._terrainGraphics=new Map}static getDimensions(){return this._dimensions}static graphics(e,r){return this._terrainGraphics.has(e)||console.error("missing graphics for TerrainType",P.getTypeName(e)),this._terrainGraphics.get(e).has(r)||console.error("missing graphics for TerrainShape:",P.getShapeName(r)),this._terrainGraphics.get(e).get(r)}static featureGraphics(e){return console.assert(this._featureGraphics.has(e),"missing terrain feature",P.getFeatureName(e)),this._featureGraphics.get(e)}static addGraphic(e,r,n,i,s,o,h){let a=new I(n,i,s,o,h),c=new H(a.id);this._terrainGraphics.has(e)||this._terrainGraphics.set(e,new Map),this._terrainGraphics.get(e).set(r,c)}static addFeatureGraphics(e,r){this._featureGraphics.set(e,r)}static isSupportedFeature(e){return this._featureGraphics.has(e)}static isSupportedType(e){return this._terrainGraphics.has(e)}static isSupportedShape(e,r){return this.isSupportedType(e)&&this._terrainGraphics.get(e).has(r)}static init(e){this._dimensions=e}static get width(){return this._dimensions.width}static get depth(){return this._dimensions.depth}static get height(){return this._dimensions.height}static scaleLocation(e){let r=e.x-e.x%this.width,n=e.y-e.y%this.depth,i=e.z-e.z%this.height;return new y(Math.floor(r/this.width),Math.floor(n/this.depth),Math.floor(i/this.height))}static create(e,r,n,i,s,o,h){return new P(e,r,n,i,this._dimensions,s,o,h)}static getFeatureName(e){switch(e){default:break;case 1:case 2:case 4:case 8:case 16:return"Shoreline";case 32:return"Dry Grass";case 64:return"Wet Grass";case 128:return"Mud"}return"None"}static getShapeName(e){switch(e){default:return console.error("unhandled terrain shape:",e),"invalid shape";case 0:return"flat";case 1:return"wall";case 5:return"flat north";case 6:return"flat north east";case 4:return"flat north west";case 3:return"flat east";case 2:return"flat west";case 8:return"flat south";case 9:return"flat south east";case 7:return"flat south west";case 22:return"ramp up north";case 18:return"ramp up north edge";case 21:return"ramp up east";case 17:return"ramp up east edge";case 19:return"ramp up south";case 15:return"ramp up south edge";case 20:return"ramp up west";case 16:return"ramp up west edge";case 10:return"flat north out";case 11:return"flat east out";case 12:return"flat west out";case 13:return"flat south out";case 14:return"flat alone out"}}static getTypeName(e){switch(e){default:return console.error("unhandled terrain type:",e),"invalid terrain";case 0:return"water";case 1:return"lowland 0";case 2:return"lowland 1";case 3:return"lowland 2";case 4:return"lowland 3";case 5:return"lowland 4";case 6:return"lowland 5";case 7:return"upland 0";case 8:return"upland 1";case 9:return"upland 2";case 10:return"upland 3";case 11:return"upland 4";case 12:return"upland 5"}}static isFlat(e){switch(e){default:break;case 4:case 5:case 6:case 2:case 0:case 1:case 3:case 7:case 8:case 9:case 10:case 11:case 13:case 12:case 14:return!0}return!1}static isEdge(e){switch(e){default:break;case 4:case 5:case 6:case 2:case 1:case 3:case 7:case 8:case 9:case 10:case 11:case 13:case 12:case 14:case 15:case 16:case 17:case 18:return!0}return!1}static isRampUp(e,r){switch(r){default:break;case 0:return e==18||e==22;case 2:return e==17||e==21;case 4:return e==15||e==19;case 6:return e==16||e==20}return!1}get gridX(){return this._gridX}get gridY(){return this._gridY}get gridZ(){return this._gridZ}get shape(){return this._shape}get type(){return this._type}get surfaceLocation(){return this._surfaceLocation}heightAt(e){return this.bounds.contains(e)?P.isFlat(this._shape)?this.z+this.height:this.z+e.y*this._tanTheta:null}},g=P;g._featureGraphics=new Map,g._terrainGraphics=new Map;var Pt=class{constructor(t,e,r){this._context=t;this._width=e;this._depth=r;this._surfaceTerrain=new Array;this._totalSurface=0;this._totalSubSurface=0;for(let n=0;n<this.depth;++n)this.surfaceTerrain.push(new Array(this.width))}get width(){return this._width}get depth(){return this._depth}get totalSurface(){return this._totalSurface}get totalSubSurface(){return this._totalSubSurface}get surfaceTerrain(){return this._surfaceTerrain}addSurfaceTerrain(t,e,r,n,i,s){let o=g.create(this._context,t,e,r,n,i,s);this.surfaceTerrain[e][t]=o,this._totalSurface++}addSubSurfaceTerrain(t,e,r,n,i){console.assert(this.getSurfaceTerrainAt(t,e).z>r,"adding sub-surface terrain which is above surface!"),g.create(this._context,t,e,r,n,i,0),this._totalSubSurface++}getSurfaceTerrainAt(t,e){return t<0||t>=this.width||e<0||e>=this.depth?null:this.surfaceTerrain[e][t]}getSurfaceTerrainAtPoint(t){let e=g.scaleLocation(t),r=this.getSurfaceTerrainAt(e.x,e.y);return r!=null&&r.surfaceLocation.z==t.z?r:null}getNeighbours(t){let e=new Array;for(let r of Pt.neighbourOffsets){let n=g.scaleLocation(t.surfaceLocation),i=this.getSurfaceTerrainAt(n.x+r.x,n.y+r.y);i&&e.push(i)}return e}},U=Pt;U.neighbourOffsets=[new f(-1,-1),new f(0,-1),new f(1,-1),new f(-1,0),new f(1,0),new f(-1,1),new f(0,1),new f(1,1)];var Lt=class{constructor(t,e){this._element=t;this._key=e}get element(){return this._element}get key(){return this._key}set key(t){this._key=t}},st=class{constructor(){this._items=new Array;this._indices=new Map}get indices(){return this._indices}get items(){return this._items}get size(){return this.items.length-1}get length(){return this.items.length}empty(){return this.length==0}pop(){let t=this.items[0];this.items.splice(0,1),this.indices.delete(t.element);for(let e=0;e<this.items.length;++e){let r=this.items[e];this.indices.set(r.element,e)}return this.build(),t.element}parentIdx(t){return t-1>>1}leftIdx(t){return 2*t+1}rightIdx(t){return 2*t+2}keyAt(t){return console.assert(t<this.length),this.items[t].key}insert(t,e){console.assert(!this.indices.has(t)),this.items.push(new Lt(t,Number.MAX_VALUE)),this.indices.set(t,this.size),this.setKey(t,e)}setKey(t,e){console.assert(this.indices.has(t));let r=this.indices.get(t);console.assert(r<this.length);let n=this.items[r];for(console.assert(e<=n.key),n.key=e;r>0&&this.keyAt(this.parentIdx(r))>this.keyAt(r);)this.exchange(r,this.parentIdx(r)),r=this.parentIdx(r)}exchange(t,e){console.assert(t<this.length),console.assert(e<this.length);let r=this.items[t],n=this.items[e];this.items[t]=n,this.items[e]=r,this.indices.set(r.element,e),this.indices.set(n.element,t)}build(){for(let t=this.size>>1;t>=0;t--)this.heapify(t)}heapify(t){let e=this.leftIdx(t),r=this.rightIdx(t),n=t;e<this.length&&this.keyAt(e)<this.keyAt(t)&&(n=e),r<this.length&&this.keyAt(r)<this.keyAt(t)&&(n=r),n!=t&&(this.exchange(t,n),this.heapify(n))}};var Z=(a=>(a[a.North=0]="North",a[a.NorthEast=1]="NorthEast",a[a.East=2]="East",a[a.SouthEast=3]="SouthEast",a[a.South=4]="South",a[a.SouthWest=5]="SouthWest",a[a.West=6]="West",a[a.NorthWest=7]="NorthWest",a[a.Max=8]="Max",a))(Z||{}),E=class{static getDirectionName(t){switch(t){default:break;case 0:return"north";case 1:return"north east";case 2:return"east";case 3:return"south east";case 4:return"south";case 5:return"south west";case 6:return"west";case 7:return"north west"}return console.error("unhandled direction when getting name:",t),"error"}static getVector2D(t){let e=0,r=0;switch(t){default:console.error("unhandled direction");break;case 0:r=-1;break;case 1:e=1,r=-1;break;case 2:e=1;break;case 3:e=1,r=1;break;case 4:r=1;break;case 5:e=-1,r=1;break;case 6:e=-1;break;case 7:e=-1,r=-1;break}return new R(e,r)}static getAdjacentCoord(t,e){let r=this.getVector2D(e);return t.add(r)}static getDirectionFromPoints(t,e){return this.getDirectionFromVector(e.diff(t))}static getDirectionFromVector(t){let e=t.mag(),n=180*new R(0,-e).angle(t)/Math.PI;return n<0&&(n=180+(180+n)),Math.round(n/45)}static getOppositeDirection(t){return(t+8/2)%8}},Ct=class{constructor(t){this._edgeCosts=new Map;this._waypoint=t.surfaceLocation}addNeighbour(t,e){this._edgeCosts.set(t,e)}hasNeighbour(t){return this._edgeCosts.has(t)}get neighbours(){return this._edgeCosts}get waypoint(){return this._waypoint}},Ut=class{constructor(t){this._grid=t;this._nodes=new Map;for(let e=0;e<this.grid.depth;e++)for(let r=0;r<this.grid.width;r++){let n=this.grid.getSurfaceTerrainAt(r,e);this._nodes.set(n,new Ct(n))}for(let e=0;e<this.grid.depth;e++)for(let r=0;r<this.grid.width;r++){let n=this.grid.getSurfaceTerrainAt(r,e);this.addNeighbours(n)}}get grid(){return this._grid}get nodes(){return this._nodes}getNeighbourCost(t,e){let r=t.x==e.x||t.y==e.y?2:3;return g.isFlat(t.shape)&&g.isFlat(e.shape)||t.z==e.z?r:r*2}addNeighbours(t){console.assert(this.nodes.has(t),"object not in node map: %o",t);let e=this.getAccessibleNeighbours(t);if(e.length==0)return;let r=this.nodes.get(t);for(let n of e){console.assert(this.nodes.has(n),"object not in node map: %o",n);let i=this.getNeighbourCost(t,n);r.addNeighbour(this.nodes.get(n),i)}}getAccessibleNeighbours(t){let e=this.grid.getNeighbours(t),r=new f(t.x,t.y);return e.filter(function(n){console.assert(Math.abs(t.z-n.z)<=1,"can only handle neighbours separated by 1 terrace max");let i=new f(n.x,n.y),s=E.getDirectionFromPoints(r,i),o=s!=0&&s!=2&&s!=4&&s!=6,h=E.getOppositeDirection(s);return n.z==t.z?!0:n.z>t.z&&!o?g.isRampUp(n.shape,s):n.z<t.z&&!o?g.isRampUp(n.shape,h):!1})}findPath(t,e){let r=this.grid.getSurfaceTerrainAtPoint(t),n=this.grid.getSurfaceTerrainAtPoint(e);if(r==null||n==null)return new Array;let i=this.nodes.get(r);if(i.neighbours.size==0)return new Array;let s=this.nodes.get(n);if(s.neighbours.size==0)return new Array;let o=new st,h=new Map,a=new Map;o.insert(i,0),h.set(i,null),a.set(i,0);let c=i;for(;!o.empty()&&(c=o.pop(),c!=s);)c.neighbours.forEach((b,d)=>{let _=a.get(c)+b;if(!a.has(d)||_<a.get(d)){a.set(d,_);let A=_;o.insert(d,A),h.set(d,c)}});if(c!=s)return Array();let l=new Array(c.waypoint);for(;c!=i;)c=h.get(c),l.push(c.waypoint);return l.reverse(),l.splice(1)}};var qe={addForValidation:function(u){return!0},addBitmap:function(u,t,e,r,n){}},Tt=class{constructor(t,e,r,n,i){this._id=t;this._x=e;this._y=r;this._width=n;this._height=i;Object.freeze(this)}get id(){return this._id}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}},It=class{constructor(t,e){this._loaded=!1;this._bitmapsToLoad=new Array;if(this._renderer=e.renderer,this._image=new Image,this._image.onload=()=>{this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.height,this.context2D=this.canvas.getContext("2d",{willReadFrequently:!0}),this.context2D.drawImage(this.image,0,0,this.width,this.height),this.loaded=!0;for(let r of this.bitmapsToLoad)this.addBitmap(r.id,r.x,r.y,r.width,r.height)},t)this._image.src=t+".png";else throw new Error("No filename passed");It.add(this)}static add(t){this._sheets.push(t)}static reset(){this._sheets=new Array}get image(){return this._image}get width(){return this._image.width}get height(){return this._image.height}get name(){return this._image.src}get loaded(){return this._loaded}set loaded(t){console.log("loaded spritesheet:",this.image.src),this._loaded=t}get canvas(){return this._canvas}set canvas(t){this._canvas=t}get context2D(){return this._context2D}set context2D(t){this._context2D=t}get bitmapsToLoad(){return this._bitmapsToLoad}isTransparentAt(t,e){return this.context2D.getImageData(t,e,1,1).data[3]==0}async addBitmap(t,e,r,n,i){this.loaded?createImageBitmap(this.image,e,r,n,i).then(s=>{this._renderer.addBitmap(t,s)}):this.bitmapsToLoad.push(new Tt(t,e,r,n,i))}},X=It;X._sheets=new Array;var at=class{constructor(t,e,r,n,i){this._sheet=t;this._width=n;this._height=i;this._offset=new f(e,r),console.assert(this.offset.x>=0,"offset.x < 0"),console.assert(this.offset.y>=0,"offset.y < 0");let s=new f(this.offset.x+this.width,this.offset.y+this.height);this._id=at.sprites.length,at.sprites.push(this),this.sheet.addBitmap(this.id,this.offset.x,this.offset.y,this.width,this.height)}isTransparentAt(t,e){return t+=this.offset.x,e+=this.offset.y,this.sheet.isTransparentAt(t,e)}get sheet(){return this._sheet}get id(){return this._id}get width(){return this._width}get height(){return this._height}get offset(){return this._offset}},I=at;I.sprites=new Array;var Qt=(r=>(r[r.AddCanvas=0]="AddCanvas",r[r.AddSprite=1]="AddSprite",r[r.Draw=2]="Draw",r))(Qt||{}),Zt=class{constructor(t,e){this._spriteId=t;this._coord=e;Object.freeze(this)}get spriteId(){return this._spriteId}get coord(){return this._coord}};function Qe(u,t,e,r,n,i,s){let o=new Array,h=r+i,a=n+s;for(let c=n;c<a;c++)for(let l=r;l<h;l++)o.push(new I(u,l*t,c*e,t,e));return o}var k=class{constructor(t){this._currentSpriteId=t}isTransparentAt(t,e){return I.sprites[this._currentSpriteId].isTransparentAt(t,e)}get width(){return I.sprites[this._currentSpriteId].width}get height(){return I.sprites[this._currentSpriteId].height}},Ht=class extends k{constructor(e,r){super(0);this._width=e;this._height=r}get width(){return this._width}get height(){return this._height}update(){return 0}},H=class extends k{constructor(t){super(t)}update(){return this._currentSpriteId}};function Ke(u,t,e,r,n,i,s){let o=new Array,h=r+i,a=n+s;for(let c=n;c<a;c++)for(let l=r;l<h;l++){let b=new I(u,l*t,c*e,t,e);o.push(new H(b.id))}return o}var ot=class extends k{constructor(e,r){super(e[0].id);this._interval=r;this._nextUpdate=0;this._currentSpriteIdx=0;this._spriteIds=new Array;for(let n in e)this._spriteIds.push(e[n].id);this._nextUpdate=Date.now()+r}update(){return this._spriteIds[this._currentSpriteIdx]}get firstId(){return this._spriteIds[0]}get lastId(){return this._spriteIds[this._spriteIds.length-1]}get currentSpriteId(){return console.assert(this._currentSpriteIdx>=0),console.assert(this._currentSpriteIdx<this._spriteIds.length),this._spriteIds[this._currentSpriteIdx]}},Xt=class extends ot{constructor(e,r){super(e,r);this._increase=!0;this._currentSpriteIdx=Math.floor(Math.random()*(this._spriteIds.length-1))}update(){return this._nextUpdate>Date.now()?this.currentSpriteId:(this._currentSpriteIdx==this._spriteIds.length-1?this._increase=!1:this._currentSpriteIdx==0&&(this._increase=!0),this._increase?this._currentSpriteIdx++:this._currentSpriteIdx--,this._nextUpdate=Date.now()+this._interval,this.currentSpriteId)}},Yt=class extends ot{constructor(t,e){super(t,e),this._currentSpriteIdx=0}update(){return this._nextUpdate>Date.now()?this.currentSpriteId:(this._currentSpriteIdx=(this._currentSpriteIdx+1)%this._spriteIds.length,this._nextUpdate=Date.now()+this._interval,this.currentSpriteId)}},jt=class extends k{constructor(e){super(0);this._staticGraphics=e;this._direction=0}get direction(){return this._direction}set direction(e){this._staticGraphics.has(e)?this._direction=e:console.log("graphic direction unsupported")}update(){return this._staticGraphics.has(this.direction)?this._staticGraphics.get(this.direction).update():(console.error("unhandled stationary graphic:",E.getDirectionName(this.direction)),0)}},qt=class extends k{constructor(e,r){super(0);this._staticGraphics=e;this._movementGraphics=r;this._stationary=!0;this._direction=0}get stationary(){return this._stationary}set stationary(e){this._stationary=e}get direction(){return this._direction}set direction(e){this._staticGraphics.has(e)&&this._movementGraphics.has(e)?this._direction=e:console.log("graphic direction unsupported")}update(){return!this.stationary&&this._movementGraphics.has(this.direction)?this._movementGraphics.get(this.direction).update():this.stationary&&this._staticGraphics.has(this.direction)?this._staticGraphics.get(this.direction).update():(this.stationary?console.error("unhandled stationary graphic:",E.getDirectionName(this.direction)):console.error("unhandled movement graphic:",E.getDirectionName(this.direction)),0)}};var ht=class{constructor(t,e){this._array=t;this._length=e}get array(){return this._array}get buffer(){return this._array.buffer}get length(){return this._length}},ct=class{addBitmap(t,e){}draw(t){}},Kt=class{constructor(t,e){this._width=t;this._height=e;this._bitmaps=new Array;this._canvas=new OffscreenCanvas(t,e),this._ctx=this._canvas.getContext("2d")}get bitmaps(){return this._bitmaps}addBitmap(t,e){t>=this.bitmaps.length&&(this.bitmaps.length=t+1),this.bitmaps[t]=e}draw(t){this._ctx.clearRect(0,0,this._width,this._height);let e=t.array;for(let r=0;r<t.length-2;r+=3){let n=e[r],i=e[r+1],s=e[r+2];console.assert(n<this.bitmaps.length,"bitmap length mismatch"),this._ctx.drawImage(this.bitmaps[n],i,s)}}},ut=class{constructor(t){this._canvas=t;this._bitmaps=new Array;this.workerBlob_=new Blob([`
    const ctx = {};
    ctx.sprites = new Array();
    ctx.valid = false;

    onmessage = function(e) {
    switch (e.data.type) {
      default:
        console.error('unhandled graphic event');
        break;
      case 0: //GraphicEvent.AddCanvas:
        ctx.width = e.data.width;
        ctx.height = e.data.height;
        ctx.canvas = e.data.canvas;
        break;
      case 1: { //GraphicEvent.AddSprite:
        const id = e.data.id;
        const sprite = e.data.sprite
        if (id == ctx.sprites.length) {
          ctx.sprites.push(sprite);
        } else if (id < ctx.sprites.length) {
          ctx.sprites[id] = sprite;
        } else {
          for (let i = ctx.sprites.length; i < id; ++i) {
            ctx.sprites.push(0);
          }
          ctx.sprites.push(sprite);
        }
        ctx.valid = false;
        break;
      }
      case 2: { //GraphicEvent.Draw:
        if (ctx.canvas == undefined) break;

        const nodes = new Int16Array(e.data.buffer);
        if (!ctx.valid) {
          for (let i = 0; i < e.data.length; i += 3) {
            const spriteId = nodes[i];
            if (spriteId >= ctx.sprites.length) return;
            if (typeof ctx.sprites[spriteId] === "number") return;
          }
          ctx.valid = true;
        }

        const ctx2d = ctx.canvas.getContext("2d");
        ctx2d.clearRect(0, 0, ctx.width, ctx.height);
        for (let i = 0; i < e.data.length; i += 3) {
          const spriteId = nodes[i];
          const x =  nodes[i+1];
          const y = nodes[i+2];
          ctx2d.drawImage(ctx.sprites[spriteId], x, y);
        }
        break;
      }
    }
  }`]);if(this._width=this.canvas.width,this._height=this.canvas.height,window.Worker){let e=this.canvas.transferControlToOffscreen(),r=window.URL.createObjectURL(this.workerBlob_);this._worker=new Worker(r),this.worker.postMessage({type:0,canvas:e,width:this.width,height:this.height},[e])}else this._ctx=this.canvas.getContext("2d")}get width(){return this._width}get height(){return this._height}get canvas(){return this._canvas}get ctx(){return this._ctx}get bitmaps(){return this._bitmaps}get worker(){return this._worker}addBitmap(t,e){window.Worker?this.worker.postMessage({type:1,id:t,sprite:e},[e]):(t>=this.bitmaps.length&&(this.bitmaps.length=t+1),this.bitmaps[t]=e)}draw(t){if(window.Worker)this.worker.postMessage({type:2,buffer:t.buffer,length:t.length},[t.buffer]);else{this.ctx.clearRect(0,0,this.width,this.height),console.assert(t.length%3==0,"elements not mod 3");let e=t.array;for(let r=0;r<t.length-2;r+=3){let n=e[r],i=e[r+1],s=e[r+2];n>=this.bitmaps.length||(console.assert(n<this.bitmaps.length,"bitmap length mismatch",n),this.ctx.drawImage(this.bitmaps[n],i,s))}}}};var ce=(r=>(r[r.Before=-1]="Before",r[r.Any=0]="Any",r[r.After=1]="After",r))(ce||{});function dt(u,t,e){return u>=t&&u<=e}var Nt=class{constructor(t,e){this._entity=t;this._succs=new Array;e.setDrawOutline(this)}updateOutline(t){this.min2D=this.min2D.add(t),this.max2D=this.max2D.add(t),this.top2D=this.top2D.add(t),this.bottom2D=this.bottom2D.add(t),this.drawCoord=this.drawCoord.add(t)}overlapDrawX(t){return dt(this.min2D.x,t.min2D.x,t.max2D.x)||dt(this.max2D.x,t.min2D.x,t.max2D.x)}overlapDrawY(t){return dt(this.top2D.y,t.top2D.y,t.bottom2D.y)||dt(this.bottom2D.y,t.top2D.y,t.bottom2D.y)}clear(){this._succs=[]}addSucc(t){this._succs.indexOf(t)==-1&&this._succs.push(t)}removeSucc(t){let e=this._succs.indexOf(t);e!=-1&&this._succs.splice(e,1)}get id(){return this._entity.id}get drawCoord(){return this._drawCoord}set drawCoord(t){this._drawCoord=t}get min2D(){return this._min2D}set min2D(t){this._min2D=t}get max2D(){return this._max2D}set max2D(t){this._max2D=t}get top2D(){return this._top2D}set top2D(t){this._top2D=t}get bottom2D(){return this._bottom2D}set bottom2D(t){this._bottom2D=t}get entity(){return this._entity}get succs(){return this._succs}get level(){return this._level}set level(t){this._level=t}get minZ(){return this._entity.bounds.minZ}get maxZ(){return this._entity.bounds.maxZ}},Ft=class{constructor(t){this._nodes=new Array;this._order=new Array;this._dirty=!0;this._minZ=t.minZ,this._maxZ=t.maxZ,this._nodes.push(t),t.level=this}get nodes(){return this._nodes}get order(){return this._order}set order(t){this._order=t}get minZ(){return this._minZ}get maxZ(){return this._maxZ}get dirty(){return this._dirty}set dirty(t){this._dirty=t}inrange(t){return t.bounds.minZ>=this._minZ&&t.bounds.minZ<this._maxZ}add(t,e){this.dirty=!0,t.level=this,this._nodes.push(t),this.update(t,e)}remove(t){this.dirty=!0;let e=this._nodes.indexOf(t);console.assert(e!=-1),this._nodes.splice(e,1),this._nodes.forEach(r=>r.removeSucc(t))}update(t,e){t.clear();for(let r=0;r<this._nodes.length;r++){let n=this._nodes[r];if(n.id==t.id)continue;let i=e.drawOrder(t,n);i==-1?t.addSucc(n):i==1?n.addSucc(t):n.removeSucc(t)}this.dirty=!0}shouldDraw(t,e){let r=t.entity;if(r.visible&&r.drawable){let n=r.graphics[0].width,i=r.graphics[0].height;return e.isOnScreen(t.drawCoord,n,i)}else return!1}buildGraph(t,e,r){if(!r&&!this.dirty)return;let n=this._nodes.filter(o=>this.shouldDraw(o,e));n.sort((o,h)=>t.drawOrder(o,h)),this.order=[];let i=new Set,s=o=>{if(!i.has(o)){i.add(o);for(let h of o.succs)s(h);this.order.push(o)}};for(let o in n)i.has(n[o])||s(n[o]);this.dirty=!1}},lt=class{constructor(){this._levels=new Array;this._numNodes=0;this._prevCameraLower=new f(0,0);this._prevCameraUpper=new f(0,0)}updateDrawOutline(t){let r=t.entity.bounds.minLocation,i=this.getDrawCoord(r).diff(t.min2D);t.updateOutline(i)}setDrawOutline(t){let e=t.entity,r=e.bounds.minLocation,n=e.bounds.maxLocation;t.min2D=this.getDrawCoord(r),t.max2D=this.getDrawCoord(n),t.top2D=this.getDrawCoord(new y(n.x,r.y,n.z)),t.bottom2D=this.getDrawCoord(new y(r.x,n.y,r.z));let i=t.min2D.diff(t.top2D),s=new f(t.min2D.x,t.min2D.y-i.y);t.drawCoord=s}get levels(){return this._levels}get initialised(){return this.levels.length!=0}get numNodes(){return this._numNodes}updateNode(t){if(!this.initialised)return;this.updateDrawOutline(t),console.assert(t.level!=null,"node with id:",t.entity.id,"isn't assigned a level!");let e=t.level;e.inrange(t.entity)?e.update(t,this):(e.remove(t),this.insertIntoLevel(t))}insertIntoLevel(t){for(let e of this.levels)if(e.inrange(t.entity)){e.add(t,this);return}this.levels.push(new Ft(t))}insertNode(t){this.setDrawOutline(t),this.initialised&&this.insertIntoLevel(t)}initialise(t){let e=new Array;for(let r of t.values())e.push(r),this.setDrawOutline(r);e.sort((r,n)=>r.minZ<n.minZ?-1:r.minZ>n.minZ?1:0),e.forEach(r=>this.insertIntoLevel(r))}cameraHasMoved(t){let e=t.min,r=t.max,n=this._prevCameraLower.x!=e.x||this._prevCameraLower.y!=e.y||this._prevCameraUpper.x!=r.x||this._prevCameraUpper.y!=r.y;return this._prevCameraLower=e,this._prevCameraUpper=r,n}buildLevels(t,e){this.cameraHasMoved(t)&&(e=!0),this._levels.forEach(r=>r.buildGraph(this,t,e))}},j=class{constructor(t){this._graph=t;this._nodes=new Map;this._numEntities=0;this._handler=new rt}get graph(){return this._graph}get numEntities(){return this._numEntities}get nodes(){return this._nodes}get ctx(){return null}insertEntity(t){let e=new Nt(t,this.graph);this.nodes.set(e.id,e),this.graph.initialised&&this.graph.insertNode(e),this._numEntities++}updateEntity(t){console.assert(this._nodes.has(t.id));let e=this._nodes.get(t.id);this.graph.updateNode(e)}getNode(t){return console.assert(this.nodes.has(t)),this.nodes.get(t)}getLocationAt(t,e,r){let n=this.getEntityDrawnAt(t,e,r);return n!=null?n.bounds.minLocation:null}getEntityDrawnAt(t,e,r){for(let n=this.graph.levels.length-1;n>=0;n--){let i=this.graph.levels[n];for(let s=0;s<i.nodes.length;s++){let o=i.nodes[s],h=o.entity;if(!h.visible||!h.drawable||!r.isOnScreen(o.drawCoord,h.width,h.depth))continue;let a=r.getDrawCoord(o.drawCoord),c=h.graphic;if(!(t<a.x||e<a.y||t>a.x+c.width||e>a.y+c.height)&&!c.isTransparentAt(t-a.x,e-a.y))return h}}return null}addTimedEvent(t){this._handler.add(t)}numToDraw(){let t=0;return this.graph.levels.forEach(e=>{t+=e.order.length}),t}render(t,e){this.graph.initialised||this.graph.initialise(this.nodes),this.graph.buildLevels(t,e);let n=this.numToDraw()*2*3*2,i=new ArrayBuffer(n),s=new Int16Array(i),o=0;return this.graph.levels.forEach(h=>{for(let a=h.order.length-1;a>=0;a--){let c=h.order[a],l=c.entity,b=t.getDrawCoord(c.drawCoord);if(l.graphics.length*3+o>=s.length){let d=new ArrayBuffer(i.byteLength*2);new Int16Array(d).set(new Int16Array(i)),i=d,s=new Int16Array(i)}l.graphics.forEach(d=>{let _=d.update();s[o]=_,s[o+1]=b.x,s[o+2]=b.y,o+=3})}}),this._handler.service(),new ht(s,o)}verifyRenderer(t){this.graph.numNodes!=t.length&&console.error("top-level comparison between scene node and entities failed");let e=0,r=new Array,n=new Array,i=new Array;for(let s of this.graph.levels)e+=s.nodes.length,s.nodes.forEach(o=>r.push(o.id));for(let s of this.nodes.values())n.push(s.id);if(t.forEach(s=>i.push(s.id)),n.length!=i.length||n.length!=r.length)return console.error("number of scene nodes and entities don't match up"),!1;this.numEntities!=t.length&&console.error("mismatch in number of entities in context and scene"),n.sort((s,o)=>s<o?-1:1),i.sort((s,o)=>s<o?-1:1),r.sort((s,o)=>s<o?-1:1);for(let s=0;s<n.length;++s){if(s!=n[s])return console.error("mismatch in expected ids:",s,n[s]),!1;if(n[s]!=i[s])return console.error("mismatch node vs entity ids:",n[s],i[s]),!1;if(n[s]!=r[s])return console.error("mismatch top level node vs found in level ids:",n[s],r[s]),!1}return!0}},Jt=(e=>(e[e.TrueIsometric=0]="TrueIsometric",e[e.TwoByOneIsometric=1]="TwoByOneIsometric",e))(Jt||{}),Y=class extends L{static physicalWidth(t){return Math.round(t*this._oneOverSqrt3)}static physicalDepth(t,e){let r=e.depth/e.width;return Math.round(t*r)}static physicalHeight(t,e){let r=e.height/e.width;return Math.round(t*r)}constructor(t,e){let r=Y.physicalWidth(t),n=Y.physicalDepth(r,e),i=Y.physicalHeight(r,e);super(r,n,i)}},Mt=Y;Mt._oneOverSqrt3=1/Math.sqrt(3);var zt=class extends lt{constructor(){super()}static getDrawCoord(t){let e=Math.round(this._halfSqrt3*(t.x+t.y)),r=Math.round(.5*(t.y-t.x)-t.z);return new f(e,r)}getDrawCoord(t){return zt.getDrawCoord(t)}drawOrder(t,e){return 0}},V=zt;V._sqrt3=Math.sqrt(3),V._halfSqrt3=Math.sqrt(3)*.5;var pt=class extends lt{constructor(){super()}static getDrawCoord(t){let e=Math.round((t.x+t.y)*2*this._oneOverMagicRatio),r=Math.round((t.y-t.x-t.z)*this._oneOverMagicRatio);return new f(e,r)}static getDimensions(t,e){let r=t*.25,n=t*.5,i=r*this._magicRatio,s=n*Math.sin(Math.atan(.5)),o=(e-n)*this._magicRatio;return new L(Math.round(i),Math.round(s),Math.round(o))}static drawOrder(t,e){return!t.entity.bounds.axisOverlapX(e.entity.bounds)&&!t.entity.bounds.axisOverlapY(e.entity.bounds)&&!t.entity.bounds.axisOverlapZ(e.entity.bounds)&&!t.overlapDrawX(e)&&!t.overlapDrawY(e)?0:t.entity.bounds.maxZ<=e.entity.bounds.minZ?-1:e.entity.bounds.maxZ<=t.entity.bounds.minZ?1:t.entity.bounds.maxY<=e.entity.bounds.minY?-1:e.entity.bounds.maxY<=t.entity.bounds.minY?1:t.entity.bounds.minX>=e.entity.bounds.maxX?-1:e.entity.bounds.minX>=t.entity.bounds.maxX?1:0}getDrawCoord(t){return pt.getDrawCoord(t)}drawOrder(t,e){return pt.drawOrder(t,e)}},W=pt;W._magicRatio=Math.cos(Math.atan(.5)),W._oneOverMagicRatio=1/Math.cos(Math.atan(.5));var kt=class{constructor(t,e,r,n){this._pos=t;this._moisture=e;this._direction=r;this._rain=n}get x(){return this._pos.x}get y(){return this._pos.y}get pos(){return this._pos}set pos(t){this._pos=t}get moisture(){return this._moisture}set moisture(t){this._moisture=t}get rain(){return this._rain}get minHeight(){return this.rain.minHeight}get direction(){return this._direction}get surface(){return this.rain.surface}dropMoisture(t){let e=this.moisture*.1*t;this.moisture-=e,this.rain.addMoistureAt(this.pos,e)}move(){for(;this.surface.inbounds(this.pos);){let t=E.getAdjacentCoord(this.pos,this.direction);if(!this.surface.inbounds(t)){this.dropMoisture(1);return}let e=this.surface.at(this.x,this.y);if(e.height<=this.minHeight||e.terrace<1){this.pos=t;continue}let n=this.surface.at(t.x,t.y).terrace>e.terrace?1.5:1;this.dropMoisture(n),this.pos=t}}},mt=class{constructor(t,e,r,n){this._surface=t;this._minHeight=e;this._clouds=Array();this._totalClouds=0;this._moistureGrid=new Array;for(let i=0;i<this.surface.depth;i++)this._moistureGrid.push(new Float32Array(this.surface.width));switch(n){default:console.error("unhandled direction");break;case 0:{let i=this.surface.depth-1;for(let s=0;s<this.surface.width;s++)this.addCloud(new f(s,i),r,n);break}case 2:{for(let s=0;s<this.surface.depth;s++)this.addCloud(new f(0,s),r,n);break}case 4:{for(let s=0;s<this.surface.width;s++)this.addCloud(new f(s,0),r,n);break}case 6:{let i=this.surface.width-1;for(let s=0;s<this.surface.depth;s++)this.addCloud(new f(i,s),r,n);break}}}get clouds(){return this._clouds}get totalClouds(){return this._totalClouds}get surface(){return this._surface}get minHeight(){return this._minHeight}get moistureGrid(){return this._moistureGrid}moistureAt(t,e){return this._moistureGrid[e][t]}addMoistureAt(t,e){this.moistureGrid[t.y][t.x]+=e}addCloud(t,e,r){this.clouds.push(new kt(t,e,r,this)),this._totalClouds++}run(){for(;this.clouds.length!=0;){let t=this.clouds[this.clouds.length-1];this.clouds.pop(),t.move()}}};var ue=(d=>(d[d.Water=0]="Water",d[d.Desert=1]="Desert",d[d.Grassland=2]="Grassland",d[d.Shrubland=3]="Shrubland",d[d.MoistForest=4]="MoistForest",d[d.WetForest=5]="WetForest",d[d.RainForest=6]="RainForest",d[d.Rock=7]="Rock",d[d.Tundra=8]="Tundra",d[d.AlpineGrassland=9]="AlpineGrassland",d[d.AlpineMeadow=10]="AlpineMeadow",d[d.AlpineForest=11]="AlpineForest",d[d.Taiga=12]="Taiga",d))(ue||{});function mr(u){switch(u){default:return console.error("unhandled biome type:",u),"invalid biome";case 0:return"water";case 1:return"desert";case 2:return"grassland";case 3:return"shrubland";case 4:return"moist forest";case 5:return"wet forest";case 6:return"rain forest";case 8:return"tundra";case 9:return"alpine grassland";case 10:return"alpine meadow";case 11:return"alpine forest";case 12:return"taiga"}}function de(u){let t=0,e=0;for(let r of u){let n=r.reduce(function(i,s){return i+s},0);t+=n,e+=r.length}return t/e}function le(u,t,e,r){let n=0,i=r.length*r.length;for(let s in r){let o=e+r[s];for(let h in r){let a=t+r[h];n+=u[o][a]}}return n/i}function pe(u,t,e,r){let n=le(u,t,e,r);if(n==0)return 0;let i=new Array,s=r.length;for(let o in r){let h=e+r[o],a=new Float32Array(s),c=0;for(let l in r){let b=t+r[l],d=u[h][b]-n;a[c]=d*d,c++}i.push(a)}return Math.sqrt(de(i))}function me(u,t,e){let n=Math.floor(2.5),i=[-2,-1,0,1,2],s=[4,1,0,1,4],o=new Array;for(let a=0;a<n;a++)o[a]=u[a];for(let a=e-n;a<e;a++)o[a]=u[a];let h=new Float32Array(5);for(let a=n;a<e-n;a++){o[a]=new Float32Array(t);for(let c=0;c<n;c++)o[a][c]=u[a][c];for(let c=t-n;c<t;c++)o[a][c]=u[a][c];for(let c=n;c<t-n;c++){let l=pe(u,c,a,i);if(l==0)continue;let b=l*l,d=Math.sqrt(2*Math.PI*b),_=0;for(let D in s){let N=Math.exp(-(s[D]/(2*b)));h[D]=N/d,_+=h[D]}for(let D of h)D/=_;let A=0;for(let D in i){let N=i[D];A+=u[a][c+N]*h[D]}for(let D in i){let N=i[D];A+=u[a+N][c]*h[D]}o[a][c]=A}}return o}var Rt=class{constructor(t,e,r){this._x=t;this._y=e;this._height=r;this._fixed=!1;this._moisture=0,this._biome=0,this._terrace=0,this._type=0,this._shape=0,this._features=0}get x(){return this._x}get y(){return this._y}get pos(){return new f(this._x,this._y)}get height(){return this._height}get terrace(){return this._terrace}set terrace(t){this._terrace=t}get type(){return this._type}set type(t){this._type=t}get shape(){return this._shape}set shape(t){this._shape=t}get features(){return this._features}set features(t){this._features|=t}get moisture(){return this._moisture}set moisture(t){this._moisture=t}get biome(){return this._biome}set biome(t){this._biome=t}get fixed(){return this._fixed}set fixed(t){this._fixed=t}},Gt=class{constructor(t,e){this._width=t;this._depth=e;this._surface=new Array}get width(){return this._width}get depth(){return this._depth}init(t){for(let e=0;e<this._depth;e++){this._surface.push(new Array);for(let r=0;r<this._width;r++){let n=t[e][r];this._surface[e].push(new Rt(r,e,n))}}}inbounds(t){return!(t.x<0||t.x>=this._width||t.y<0||t.y>=this._depth)}at(t,e){return this._surface[e][t]}getNeighbours(t,e){let r=new Array;for(let n=-1;n<2;n++){let i=e+n;if(!(i<0||i>=this._depth))for(let s=-1;s<2;s++){let o=t+s;o<0||o>=this._width||o==t&&i==e||r.push(this._surface[i][o])}}return r}},$t=class{constructor(t,e,r){this._numTerraces=t;this._defaultFloor=e;this._defaultWall=r;this._waterLine=0;this._wetLimit=0;this._dryLimit=0;this._uplandThreshold=0;this._hasWater=!1;this._hasRamps=!1;this._hasBiomes=!1;this._rainfall=0;this._rainDirection=0;console.assert(t>0)}get waterLine(){return this._waterLine}set waterLine(t){this._waterLine=t}get wetLimit(){return this._wetLimit}set wetLimit(t){this._wetLimit=t}get rainfall(){return this._rainfall}set rainfall(t){this._rainfall=t}get uplandThreshold(){return this._uplandThreshold}set uplandThreshold(t){this._uplandThreshold=t}get rainDirection(){return this._rainDirection}set rainDirection(t){this._rainDirection=t}get dryLimit(){return this._dryLimit}set dryLimit(t){this._dryLimit=t}get hasWater(){return this._hasWater}set hasWater(t){this._hasWater=t}set hasRamps(t){this._hasRamps=t}set hasBiomes(t){this._hasBiomes=t}get numTerraces(){return this._numTerraces}get floor(){return this._defaultFloor}get wall(){return this._defaultWall}get ramps(){return this._hasRamps}get biomes(){return this._hasBiomes}},te=class{constructor(t,e,r,n,i){this._config=n;g.init(i);let s=0,o=0;for(let h=0;h<e;h++){let a=r[h],c=a.reduce(function(b,d){return Math.max(b,d)}),l=a.reduce(function(b,d){return Math.min(b,d)});s=Math.min(s,l),o=Math.max(o,c)}if(s<0){s=Math.abs(s);for(let h=0;h<e;h++)for(let a=0;a<t;a++)r[h][a]+=s;o+=s}this._terraceSpacing=o/this.config.numTerraces,this._surface=new Gt(t,e),this.surface.init(r);for(let h=0;h<this.surface.depth;h++)for(let a=0;a<this.surface.width;a++){let c=this.surface.at(a,h);c.terrace=Math.floor(c.height/this._terraceSpacing),c.shape=0,c.type=this.config.floor,console.assert(c.terrace<=this.config.numTerraces&&c.terrace>=0,"terrace out of range:",c.terrace)}}get config(){return this._config}get surface(){return this._surface}get terraceSpacing(){return this._terraceSpacing}hasFeature(t,e,r){return console.assert(t>=0&&t<this.surface.width&&e>=0&&e<this.surface.depth),(this.surface.at(t,e).features&r)!=0}terrainTypeAt(t,e){return console.assert(t>=0&&t<this.surface.width&&e>=0&&e<this.surface.depth),this.surface.at(t,e).type}terrainShapeAt(t,e){return console.assert(t>=0&&t<this.surface.width&&e>=0&&e<this.surface.depth),this.surface.at(t,e).shape}moistureAt(t,e){return console.assert(t>=0&&t<this.surface.width&&e>=0&&e<this.surface.depth),this.surface.at(t,e).moisture}isFlatAt(t,e){return console.assert(t>=0&&t<this.surface.width&&e>=0&&e<this.surface.depth),g.isFlat(this.surface.at(t,e).shape)}biomeAt(t,e){return console.assert(t>=0&&t<this.surface.width&&e>=0&&e<this.surface.depth),this.surface.at(t,e).biome}relativeHeightAt(t,e){return console.assert(t>=0&&t<this.surface.width&&e>=0&&e<this.surface.depth),this.surface.at(t,e).terrace}generateMap(t){this.config.ramps&&this.setShapes(),this.config.rainfall>0&&this.addRain(this.config.rainDirection,this.config.rainfall,this.config.waterLine),(this.config.biomes||this.config.hasWater)&&this.setBiomes(),this.setEdges(),this.setFeatures();let e=new U(t,this.surface.width,this.surface.depth);for(let r=0;r<this.surface.depth;r++)for(let n=0;n<this.surface.width;n++){let i=this.surface.at(n,r);console.assert(i.terrace<=this.config.numTerraces&&i.terrace>=0,"terrace out-of-range",i.terrace),e.addSurfaceTerrain(n,r,i.terrace,i.type,i.shape,i.features)}for(let r=0;r<this.surface.depth;r++)for(let n=0;n<this.surface.width;n++){let i=this.surface.at(n,r).terrace,s=i-this.calcRelativeHeight(n,r),o=e.getSurfaceTerrainAt(n,r);o==null&&console.error("didn't find terrain in map at",n,r,i);let h=g.isFlat(o.shape)?o.shape:0;for(;i>s;)i--,e.addSubSurfaceTerrain(n,r,i,o.type,h)}return e}setShapes(){let t=[new f(0,1),new f(-1,0),new f(0,-1),new f(1,0)],e=[19,20,22,21],r=0;for(let n=this.surface.depth-3;n>1;n--)for(let i=2;i<this.surface.width-2;i++){let s=this.surface.at(i,n);if(!(!g.isFlat(s.shape)||s.height+this.terraceSpacing/2!=(s.terrace+1)*this.terraceSpacing))for(let h in t){let a=t[h],c=this.surface.at(s.x+a.x,s.y+a.y),l=this.surface.at(c.x+a.x,c.y+a.y);!c.fixed&&!l.fixed&&c.terrace==s.terrace+1&&c.terrace==l.terrace&&(c.shape=e[h],c.fixed=!0,l.fixed=!0,r++)}}}setEdges(){for(let t=0;t<this.surface.depth;t++)for(let e=0;e<this.surface.width;e++){let r=this.surface.at(e,t);if(r.type==0)continue;let n=this.surface.getNeighbours(e,t),i=r.shape,s=!1,o=!1,h=!1,a=!1;for(let c of n)if(!(c.terrace>r.terrace)&&!(c.x!=r.x&&c.y!=r.y)&&!(c.terrace==r.terrace&&g.isFlat(r.shape)==g.isFlat(c.shape))&&(s=s||c.y<r.y,h=h||c.y>r.y,o=o||c.x>r.x,a=a||c.x<r.x,s&&o&&h&&a))break;if(i==0?s&&o&&h&&a?i=14:s&&o&&a?i=10:s&&o&&h?i=11:o&&h&&a?i=13:h&&a&&s?i=12:s&&o?i=6:s&&a?i=4:s?i=5:h&&o?i=9:h&&a?i=7:h?i=8:o?i=3:a&&(i=2):i==22&&o?g.isSupportedShape(r.type,18)&&(i=18):i==21&&s?g.isSupportedShape(r.type,17)&&(i=17):i==19&&o?g.isSupportedShape(r.type,15)&&(i=15):i==20&&s&&g.isSupportedShape(r.type,16)&&(i=16),r.terrace>0&&i==0&&n.length!=8&&(i=1),g.isFlat(i)&&g.isEdge(i)&&(this.config.biomes||(r.type=this.config.wall),!g.isSupportedShape(r.type,i)))switch(i){default:i=1;break;case 10:g.isSupportedShape(r.type,5)?i=5:i=1;break;case 6:case 9:g.isSupportedShape(r.type,3)?i=3:i=1;break;case 4:g.isSupportedShape(r.type,12)?i=12:i=1;break;case 7:g.isSupportedShape(r.type,2)?i=2:i=1;break}!g.isFlat(i)&&!g.isSupportedShape(r.type,i)&&(g.isSupportedShape(this.config.floor,i)?r.type=this.config.floor:g.isSupportedShape(this.config.wall,i)&&(r.type=this.config.wall)),g.isSupportedShape(r.type,i)||(i=0),r.shape=i}}calcRelativeHeight(t,e){let r=this.surface.getNeighbours(t,e),n=0,i=this.surface.at(t,e);for(let s of r){console.assert(s.terrace>=0,"Found neighbour with negative terrace!",s.terrace);let o=i.terrace-s.terrace;n=Math.max(o,n)}return console.assert(n<=this.config.numTerraces,"impossible relative height:",n,`
centre:`,i),n}addRain(t,e,r){let n=new mt(this.surface,r,e,t);n.run();let i=me(n.moistureGrid,this.surface.width,this.surface.depth);for(let s=0;s<this.surface.depth;s++)for(let o=0;o<this.surface.width;o++){let h=this.surface.at(o,s);h.moisture=i[s][o]}}setBiomes(){for(let e=0;e<this.surface.depth;e++)for(let r=0;r<this.surface.width;r++){let n=this.surface.at(r,e),i=0,s=0,o=Math.min(1,n.moisture/6),h=Math.floor(5*o);if(n.height<=this.config.waterLine)i=0,s=0;else if(n.height>=this.config.uplandThreshold)switch(h){default:console.error("unhandled moisture scale");break;case 0:i=7,s=7;break;case 1:i=8,s=8;break;case 2:i=9,s=9;break;case 3:i=10,s=10;break;case 4:i=11,s=11;break;case 5:i=12,s=12;break}else switch(h){default:console.error("unhandled moisture scale");break;case 0:i=1,s=1;break;case 1:i=2,s=2;break;case 2:i=3,s=3;break;case 3:i=4,s=4;break;case 4:i=5,s=5;break;case 5:i=6,s=6;break}g.isSupportedType(s)?n.type=s:console.log("unsupported biome terrain type:",g.getTypeName(s)),n.biome=i}}setFeatures(){for(let t=0;t<this.surface.depth;t++)for(let e=0;e<this.surface.width;e++){let r=this.surface.at(e,t);if(g.isFlat(r.shape)){let n=this.surface.getNeighbours(r.x,r.y);for(let i of n)if(i.biome==0)switch(E.getDirectionFromPoints(r.pos,i.pos)){default:break;case 0:r.features|=2;break;case 2:r.features|=4;break;case 4:r.features|=8;break;case 6:r.features|=16;break}r.biome==2?r.features|=32:r.biome==8&&(r.features|=32)}}}};var gt=class{constructor(t){this._bounds=t;this._children=new Array;this._entities=new Array}get children(){return this._children}get entities(){return this._entities}get bounds(){return this._bounds}get centre(){return this._bounds.centre}get width(){return this._bounds.width}get height(){return this._bounds.height}get depth(){return this._bounds.depth}get recursiveCountNumEntities(){if(this.entities.length!=0)return this.entities.length;let t=0;for(let e of this.children)t+=e.recursiveCountNumEntities;return t}insert(t){let e=!1;if(this.children.length==0)this.entities.push(t),this.bounds.insert(t.bounds),this.entities.length>gt.MaxEntities?e=this.split():e=!0;else{for(let r of this.children)if(r.bounds.containsBounds(t.bounds)){e=r.insert(t);break}if(!e){for(let r of this.children)if(r.containsLocation(t.centre)){e=r.insert(t);break}}}return console.assert(e,"failed to insert entity into octree node"),e}split(){this._children=new Array;let t=this.bounds.width/2,e=this.bounds.depth/2,r=this.bounds.height/2,n=new L(t,e,r),i=[-.5,.5];for(let o=0;o<2;o++)for(let h=0;h<2;h++)for(let a=0;a<2;a++){let c=i[a]*n.width,l=i[h]*n.depth,b=i[o]*n.height,d=new y(this.centre.x+c,this.centre.y+l,this.centre.z+b),_=new C(d,n);this.children.push(new gt(_))}let s=function(o,h){return o.containsLocation(h.bounds.centre)?o.insert(h):!1};for(let o of this._entities){let h=!1;for(let a of this._children)if(s(a,o)){h=!0;break}console.assert(h,"failed to insert into children, entity centred at:",o.bounds.centre)}return this._entities=[],!0}containsBounds(t){return this.bounds.containsBounds(t)}containsLocation(t){return this.bounds.contains(t)}containsEntity(t){return this.entities.indexOf(t)!=-1}recursivelyContainsEntity(t){if(this.containsEntity(t))return!0;for(let e of this._children)if(e.recursivelyContainsEntity(t))return!0;return!1}recursiveRemoveEntity(t){let e=this.entities.indexOf(t);if(e!=-1)return this.entities.splice(e,1),!0;for(let r of this.children)if(r.recursiveRemoveEntity(t))return!0;return!1}},ft=gt;ft.MaxEntities=30;var bt=class{constructor(t){this._numEntities=0;let e=t.width/2,r=t.depth/2,n=t.height/2,i=new y(e,r,n);this._worldBounds=new C(i,t),this._root=new ft(this._worldBounds)}get root(){return this._root}get bounds(){return this.root.bounds}insert(t){let e=this._root.insert(t);console.assert(e,"failed to insert"),this._numEntities++}findEntitiesInArea(t,e,r){if(t.entities.length!=0)t.entities.forEach(n=>r.push(n));else for(let n of t.children)n.bounds.intersects(e)&&this.findEntitiesInArea(n,e,r)}getEntities(t){let e=new Array;return this.findEntitiesInArea(this.root,t,e),e}update(t){let e=this.root.recursiveRemoveEntity(t);console.assert(e),this._numEntities--,this.insert(t)}verify(t){for(let e of t)if(!this._root.recursivelyContainsEntity(e))return console.error("tree doesn't contain entity at (x,y,z):",e.x,e.y,e.z),!1;return!0}};var B=class{constructor(t,e){this._entities=new Array;this._updateables=new Array;this._movables=new Array;this._controllers=new Array;this._totalEntities=0;switch(this._spatialGraph=new bt(t),v.init(this._spatialGraph),e){default:console.error("unhandled perspective");break;case 0:this._scene=new j(new V);break;case 1:this._scene=new j(new W);break}this._renderer=new ct}static reset(){T.reset(),g.reset(),X.reset()}get scene(){return this._scene}get renderer(){return this._renderer}get entities(){return this._entities}get bounds(){return this._spatialGraph.bounds}get spatial(){return this._spatialGraph}get controllers(){return this._controllers}verify(){return this.entities.length==T.getNumEntities()&&this.entities.length==this._totalEntities&&this.spatial.verify(this.entities)&&this.scene.verifyRenderer(this.entities)}addOnscreenRenderer(t){this._renderer=new ut(t)}addController(t){this._controllers.push(t)}addEntity(t){this.entities.length==0?t.id!=0&&console.error("Adding entity with unexpected id:",t.id):this.entities.length>0&&t.id!=this.entities[this.entities.length-1].id+1&&console.error("Adding entity with unexpected id:",t.id),this.entities.push(t),this.spatial.insert(t),this.scene.insertEntity(t),this._totalEntities++}addUpdateableEntity(t){this._updateables.push(t)}addMovableEntity(t){this._movables.push(t),t.addEventListener("moving",()=>{this.spatial.update(t),this.scene.updateEntity(t)})}update(t){t.update();let e=this._scene.render(t,!1);this.renderer.draw(e),O.update(this._movables),this._updateables.forEach(r=>{r.update()}),this._controllers.forEach(r=>{r.update()})}};function Mr(u,t,e){B.reset();let r=new B(t,e);return r.addOnscreenRenderer(u),r}function Nr(u,t){return B.reset(),new B(u,t)}var yt=class{constructor(t,e,r){this._scene=t;this._lowerX=0;this._lowerY=0;this._handler=new G;this._width=Math.floor(e),this._height=Math.floor(r),this._upperX=Math.floor(e),this._upperY=Math.floor(r),this._surfaceLocation=t.getLocationAt(this._lowerX,this._lowerY,this)}isOnScreen(t,e,r){return!(t.x+e<this._lowerX||t.y+r<this._lowerY||t.x-e>this._upperX||t.y-r>this._upperY)}get min(){return new f(this._lowerX,this._lowerY)}get max(){return new f(this._upperX,this._upperY)}get width(){return this._width}get height(){return this._height}get location(){return this._surfaceLocation}set location(t){if(t==null){console.log("undefined camera surface location");return}let e=this._scene.graph.getDrawCoord(t);this.x=e.x,this.y=e.y,this._handler.post("cameraMove"),this._surfaceLocation=t}set x(t){this._lowerX=t-Math.floor(this.width/2),this._upperX=t+Math.floor(this.width/2)}set y(t){this._lowerY=t-Math.floor(this.height/2),this._upperY=t+Math.floor(this.height/2)}getDrawCoord(t){return new f(t.x-this._lowerX,t.y-this._lowerY)}update(){this._handler.service()}addEventListener(t,e){this._handler.addEventListener(t,e)}removeEventListener(t,e){this._handler.removeEventListener(t,e)}},ee=class extends yt{constructor(t,e,r,n){super(t,r,n),e.addEventListener("mousedown",i=>{i.button==0&&(this.location=t.getLocationAt(i.offsetX,i.offsetY,this))}),e.addEventListener("touchstart",i=>{let s=i.touches[0];this.location=t.getLocationAt(s.pageX,s.pageY,this)})}},re=class extends yt{constructor(t,e,r,n){super(t,e,r),this.location=n.centre,n.addEventListener("moving",()=>{this.location=n.centre})}};var _t=class{constructor(t){this._actor=t}get actor(){return this._actor}set actor(t){this._actor=t}},xt=class extends _t{constructor(t){super(t)}obstructed(t,e){let r=this._actor.bounds,n=e.vec_diff(t),i=new C(e,r.dimensions);return i.insert(r),v.detectInArea(this._actor,n,i)}perform(){return!0}},ne=class extends xt{constructor(e,r,n){super(e);this._d=r;this._bounds=n}perform(){let e=this.actor.bounds.bottomCentre,r=e.add(this._d),n=this.obstructed(e,r);return n==null?(this.actor.updatePosition(this._d),!1):n.blocking?(this.actor.postEvent("endMove"),!0):(console.log("adjusting movement with max angle"),this.actor.updatePosition(this._d),!1)}},Ot=class extends xt{constructor(e,r,n){super(e);this._step=r;this._destination=n;this.destination=n}set speed(e){this._step=e}get destination(){return this._destination}set destination(e){this._destination=e;let r=this.actor.bounds.minLocation,n=e.vec_diff(r);console.assert(n.x==0||n.y==0||n.z==0,"can only change distance along two axes simultaneously");let i=0,s=0,o=0;if(!(n.x==0&&n.y==0&&n.z==0)){if(n.x==0&&n.z==0)i=0,s=this._step,o=0;else if(n.y==0&&n.z==0)s=0,i=this._step,o=0;else if(n.x==0&&n.y==0)i=0,s=0,o=this._step;else{let h=0,a=0;n.z==0?(h=n.y>0?n.y:n.x,a=n.y>0?n.x:n.y):n.x==0?(h=n.z>0?n.y:n.z,a=n.z>0?n.z:n.y):n.y==0&&(h=n.z>0?n.x:n.z,a=n.z>0?n.z:n.x);let c=Math.atan(a/h)*180/Math.PI,l=Math.sin(c)*this._step,b=Math.cos(c)*this._step;n.z==0?(i=h==n.y?l:b,s=h==n.y?b:l):n.x==0?(o=h==n.y?l:b,s=h==n.y?b:l):n.y==0&&(i=h==n.z?l:b,o=h==n.z?b:l)}this._d=new w(i,s,o)}}perform(){console.log("perform action");let e=this.actor.bounds,r=e.minLocation,i=this.destination.vec_diff(r).absMin(this._d);return this.actor.updatePosition(i),this.actor.postEvent("moving"),e.minLocation.isSameAsRounded(this.destination)}},ie=class extends _t{constructor(e,r,n){super(e);this._step=r;this._destination=n;this._index=0}perform(){if(this._waypoints.length==0)return!0;if(!this._currentStep.perform())return!1;if(!this._currentStep.destination.isSameAsRounded(this._actor.bounds.minLocation)||(this._index++,this._index==this._waypoints.length))return!0;let r=this._waypoints[this._index];return this._currentStep=new Ot(this._actor,this._step,r),!1}};var wt=class{static pause(t){this._tracks[t].pause()}static play(t,e){e>this._maxVolume&&(e=this._maxVolume);let r=this._tracks[t];console.log("play music at:",e),r.volume=e,r.playing||r.play()}constructor(t,e){this._id=wt._tracks.length,this._track=new Audio(t),console.assert(this._track!=null,"failed to create audio"),this._track.loop=e,wt._tracks.push(this)}set volume(t){this._track.volume=t}get playing(){return!this._track.paused&&this._track.currentTime!=0}pause(){this._track.pause()}play(){this._track.play()}},M=wt;M._tracks=new Array,M._maxVolume=.8;var se=class extends M{constructor(t,e,r){super(t,!0);let n=this._id,i=Math.sqrt(Math.pow(e.maxX-e.minX,2)+Math.pow(e.maxY-e.minY,2)+Math.pow(e.maxZ-e.minZ,2))/2;console.log("centre of audio zone (x,y):",e.centre.x,e.centre.y),console.log("max distance from centre:",i);let s=function(){let o=r.location;if(o==null){console.log("couldn't get camera location");return}if(!e.contains(r.location)){console.log("camera location not inbounds"),M.pause(n);return}let h=o.x-e.centre.x,a=o.y-e.centre.y;h=Math.abs(h/i),a=Math.abs(a/i);let c=M._maxVolume*Math.exp(-8*(h+a));M.play(n,c)};r.addEventListener("cameraMove",s),window.addEventListener("focus",s),window.addEventListener("blur",()=>{M.pause(n)})}};var oe=class{constructor(t,e,r){r&&this.debugCollision(t,e)}debugCollision(t,e){let r=t.context;t.addEventListener("moving",function(){if(!v.hasMissInfo(t))return;let n=v.getMissInfo(t),i=r.scene,s=Date.now();i.addTimedEvent(function(){if(i.ctx!=null){i.ctx.strokeStyle="Green";for(let o of n){let h=i.getNode(o.id);i.ctx.beginPath(),i.ctx.moveTo(h.top2D.x,h.top2D.y),i.ctx.lineTo(h.max2D.x,h.max2D.y),i.ctx.lineTo(h.bottom2D.x,h.bottom2D.y),i.ctx.lineTo(h.min2D.x,h.min2D.y),i.ctx.lineTo(h.top2D.x,h.top2D.y),i.ctx.stroke()}}return Date.now()>s+1e3})}),t.addEventListener("collision",function(){if(console.log("collision detected"),!v.hasCollideInfo(t)){console.log("but no info available");return}let n=v.getCollideInfo(t),i=n.intersectInfo,s=n.entity,o=i.face,h=r.scene,a=Date.now();h.addTimedEvent(function(){if(h.ctx!=null){let c=h.ctx;c.strokeStyle="Green";let l=h.getNode(t.id);c.beginPath(),c.moveTo(l.top2D.x,l.top2D.y),c.lineTo(l.max2D.x,l.max2D.y),c.lineTo(l.bottom2D.x,l.bottom2D.y),c.lineTo(l.min2D.x,l.min2D.y),c.lineTo(l.top2D.x,l.top2D.y),c.stroke(),c.strokeStyle="Orange",l=h.getNode(s.id),c.beginPath(),c.moveTo(l.top2D.x,l.top2D.y),c.lineTo(l.max2D.x,l.max2D.y),c.lineTo(l.bottom2D.x,l.bottom2D.y),c.lineTo(l.min2D.x,l.min2D.y),c.lineTo(l.top2D.x,l.top2D.y),c.stroke(),c.strokeStyle="Red",c.fillStyle="Red";for(let b of o.vertices()){c.beginPath();let d=e.getDrawCoord(h.graph.getDrawCoord(b.point)),_=e.getDrawCoord(h.graph.getDrawCoord(b.point.add(b.u))),A=e.getDrawCoord(h.graph.getDrawCoord(b.point.add(b.v)));c.beginPath(),c.moveTo(d.x,d.y),c.lineTo(_.x,_.y),c.lineTo(A.x,A.y),c.closePath(),c.stroke(),c.fill()}}return Date.now()>a+1e3}),v.removeInfo(t)})}};export{_t as Action,Et as Actor,qt as AnimatedDirectionalGraphicComponent,ot as AnimatedGraphicComponent,ue as Biome,C as BoundingCuboid,yt as Camera,v as CollisionDetector,St as CollisionInfo,B as ContextImpl,K as CuboidGeometry,L as Dimensions,Z as Direction,jt as DirectionalGraphicComponent,Zt as DrawElement,ht as DrawElementList,Ht as DummyGraphicComponent,ct as DummyRenderer,qe as DummySpriteSheet,z as EntityEvent,G as EventHandler,Q as Face3D,F as Geometry,k as GraphicComponent,Qt as GraphicEvent,O as Gravity,Dt as InputEvent,vt as IntersectInfo,Mt as IsometricPhysicalDimensions,Yt as LoopGraphicComponent,st as MinPriorityQueue,ee as MouseCamera,nt as MovableEntity,oe as MovableEntityDebug,Ot as MoveDestination,ne as MoveDirection,ie as Navigate,E as Navigation,Vt as NoGeometry,Kt as OffscreenRenderer,ut as OnscreenRenderer,ae as Orientation,Xt as OssilateGraphicComponent,Ut as PathFinder,Jt as Perspective,T as PhysicalEntity,f as Point2D,y as Point3D,x as QuadFace3D,$ as RampUpEastGeometry,tt as RampUpNorthGeometry,et as RampUpSouthGeometry,J as RampUpWestGeometry,ce as RenderOrder,j as Scene,lt as SceneGraph,Ft as SceneLevel,Nt as SceneNode,q as Segment2D,M as Sound,I as Sprite,X as SpriteSheet,H as StaticGraphicComponent,Gt as Surface,g as Terrain,te as TerrainBuilder,$t as TerrainBuilderConfig,At as TerrainFeature,U as TerrainGrid,Wt as TerrainShape,Bt as TerrainType,rt as TimedEventHandler,re as TrackerCamera,V as TrueIsometric,W as TwoByOneIsometric,R as Vector2D,w as Vector3D,m as Vertex3D,se as ZonalAudioLoop,Mr as createContext,Te as createGraphicalActor,Le as createGraphicalEntity,Ce as createGraphicalMovableEntity,Nr as createTestContext,Qe as generateSprites,Ke as generateStaticGraphics,mr as getBiomeName};
